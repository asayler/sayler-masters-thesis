\chapter{Applications}
\label{chap:clients}

In Chapter \ref{chap:purpose} I discussed several potential
applications for Custos. In Chapter \ref{chap:platform} I discussed
the Custos architecture and server API. In this chapter, I'll look
more closely at several example applications that interface with the
Custos server and leverage Custos to enhance their functionality. As
with the implementations provided in Chapter \ref{chap:platform},
these applications are designed merely to serve as examples of how one
might leverage Custos. They are by no means intended to represent a
complete list of all possible Custos applications. Nor are they
designed as fully production ready systems. They are proofs of concept
that demonstrate how to use Custos and the features using Custos
brings.

\section{Encrypted File System}

As discussed, encrypted file systems are a core Custos use case. As
such, I have written a layered, encrypted pass-through file system:
\texttt{EncFS}. This file system leverages Custos for encrypted file
key storage, and leverage underlying file systems for encrypted file
storage. It enables use cases not normally available in other
encrypted file systems.

The file system is capable of supporting encrypted operation in a wide
range of scenarios. Since it is a pass-through file system, it can be
used atop Cloud storage systems like Dropbox~\cite{dropbox}, secure
storage of a users files in the cloud. Custos enables access to the
encrypted files from multiple devices or by multiple users, allowing a
user to use Dropbox as they normally would to sync files across
multiple devises or to share files with other, all while still
benefiting from encryption.

The system can also be used atop a users local file system, guarding
against data compromise in the event that the users computer is lost
or stolen. In addition, the file system has proven useful for use on
servers, where Custos's flexible authentication systems can allow for
daemon-based non-interactive access. This has allowed me to encrypt
server files like logs or mailboxes that normally must not be
encrypted in order to per-server non-interactive access by system
processes.

\subsection{Architecture}

\begin{figure}[!tb]
  \vspace{5ex}
  \begin{center}
    \includegraphics[width=.75\textwidth]
                    {./figs/pdf/App-FS-Fuse.pdf}
  \end{center}
  \caption{The \texttt{EncFS} File System Architecture}
  \label{fig:app-encfs}
\end{figure}

As Figure \ref{fig:app-encfs} shows, \texttt{EncFS} uses an
architecture similar to that described as the ``layered model'' in
Chapter \ref{chap:purpose}. It acts as a shim between user file system
operations (read, write, create, etc) and the actual realization of
these operations on the underlying file system, proving transparent
encryption in between. If the user attempts to read a file directly
from disk without first passing through the \texttt{EncFS} layer, they
will only received encrypted gibberish. But when the same file is
accessed through the \texttt{EncFS} layer, the user may interact with
the file as though it were not encrypted. As such, the user's files
are fully protected when the \texttt{EncFS} layer is not mounted or
not running, and easily accessible when this layer is mounted or is
running.

At this time \texttt{EncFS} only provides file encryption, not file
organization encryption. This is sufficient to demonstrate how to use
Custos to secure an encrypted file system, while avoiding the
complexity of also encrypting file system organization. When a user
wishes to start \texttt{EncFS}, they specify a mount point and a base
file system point. The base file system point become the root on the
\texttt{EncFS} backing file system. Any files accessed via the
\texttt{EncFS} mount point are actually stored/accessed at the
underlying base file system point. \texttt{EncFS} simply provides a
means for adding and removing encryption between the actual storage of
files on the underlying file system and the corresponding access to
files on the part of a user.

Because file systems do nor normally provide means for interactive
authentication, all necessary authentication parameters must be based
to \texttt{EncFS} at the time it is mounted/started. If a user tires
to access a file for which the combination of provided and implicit
authentication attributes are not sufficient, they are simply denied
access to the file. \texttt{EncFS} itself does to provide the ability
to manipulate Custos Access Control Specifications. Instead, this
manipulation is handled by a separate, dedicated utility program (see
below). As long as the user has the necessary permissions, all
encrypted file access via \texttt{EncFS} is fully transparent,
allowing easy integration with other applications via the started
Linux file interface~\cite{linux-vfs}.

\subsection{Implementation}

\texttt{EncFS} is implemented using the FUSE~\cite{fuse}. I chose a
FUSE-based implementation over a native Linux kernel-module
implementation for \texttt{EncFS} in order to allow easy usage of a
variety of user-space libraries (i.e. \texttt{libcustos}, OpenSSL,
etc). The basics of using FUSE to create an virtual overlay file
system like \texttt{EncFS} are described in my previous work:
~\cite{sayler-os-encfs}. FUSE provides a series of callbacks that are
triggered by various file system operations. Each callback is then
implemented by \texttt{EncFS} in C in order to provided the desired
encryption functionality.

All encryption in \texttt{EncFS} uses the AES symmetric encryption
cipher with 256-bit keys and the CBC encryption mode. Encryption
operations are handled by the OpenSSL~\cite{openssl} crypto
library\footnote{Following the old adage that one should never ``roll
  their own'' crypto. Leave it to the professionals! (Or at least to a
  widely used, well vetted code base.)}. Data written via the
\texttt{EncFS} mount point is encrypted before being committed to an
actual file on the underlying disk. Likewise, data read via the
\texttt{EncFS} mount point is decrypted before being passed back to
the user. This includes decrypting files when the user accesses
related meta-data like file size to ensure the user receives the size
of the unencrypted file content. Currently, \texttt{EncFS} encrypted
files in single blocks, meaning the entire file must be read to
decrypt any portion of it. This can have an adverse effect on access
to random offsets within a file. I plan to upgrade the system to
support breaking files into blocks in order to speed random access and
streaming operations in the near future.

\texttt{EncFS} interacts with Custos via the \texttt{libcustos}
library (see Chapter \ref{chap:platform}). This allows \texttt{EncFS}
to overlaid the complexities of the Custos API to a dedicated code
base. \texttt{libcustos} provides the necessary functions to allow
\texttt{EncFS} to read, update, and create Custos key:value
objects. When a user wishes to decrypt a file, \texttt{EncFS}
requested the associated encryption key form the Custos server using
the UUID stored with the file (either via extended attributes or in a
header block appended to the encrypted file contents, depending on
system support for extended attributes). If \texttt{EncFS} posses the
necessary authentication attributes (either supplied by the user at
mount time or derived contextually), Custos return the request key and
\texttt{EncFS} proceeds to decrypt the file. The opposite operation
occurs when a file is created or written, with \texttt{EncFS} rotating
the encryption key and uploading a new version to Custos for each
write operation.

\section{Secure Data Repository}

\subsection{Architecture}

Public, Encrypted Personal Data Store

(Name, SSN, Etc)

\subsection{Implementation}

Static Encrypted Web Content

Assessor used Custos Client

\section{Management Interface}

\subsection{Architecture}

\subsection{Implementation}

%%  LocalWords:  EncFS libcustos OpenSSL
