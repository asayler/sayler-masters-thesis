\chapter{Introduction}
\label{chap:intro}

Data is everywhere. Our devises produce it. Our web sites consume
it. Governments collect it~\cite{GreenwaldPrism} and businesses
request it. But in this ever present whirlpool of data exchange, how
can we stay in control of our data? How can we ensure that those who
we wish to can access it can while preventing those who we do not from
doing the same?

Fortunately, there are methods for securing our data: strong
cryptography systems like AES or RSA are perfectly capable of allowing
us to control exactly who can read our data. Unfortunately, these
systems are often difficult if not impossible for the average end-user
to employ properly. Other times, they are simply treated like ``magic
fairy dust''~\cite{Smith2003, schneier2000secrets} to be applied to
various products in the name of ``just-add-crypto'' security with
little heed paid to the security of the implementation or usability of
the system.

How can we make encryption more usable? How can we make it more
accessible? And how can we accomplish both while maintaining
compatibility with an array of modern use cases like data sharing and
device syncing? Custos aims to provide an answer to these questions by
providing a secure key-value secret store that can be used to
implement a ``Key Storage as a Service'' (KSaaS) platform.

The work presented in this document provides the following:

\begin{packed_item}
\item An overview of the Custos architecture, rational, and design goals
\item A discussion of various application domains in which Custos can
  be used to improve security, privacy, and usability.
\item A definition of the Custos protocol and message exchange formats.
\item A prototype Custos server implementation.
\item Several proof-of-concept applications that leverage Custos to
  add security, increase usability, and enhance features.
\end{packed_item}

\section{Overview}

At its core, Custos is just another key-value store. Actually, it's
not even that. It's just a wrapper around one of several existing
key-value stores. It is not the method of key-value storage that makes
Custos unique. Instead, it is its ability to provide flexible,
fine-grained access control to key-value pairs that make it
notable. These access control capabilities make Custos an ideal system
for implementing a secure data storage service. Such a data storage
service can be leveraged to store and manage a variety of secrets,
including secrets like encryption keys. For it is not cryptography
itself that leads to usability issues, but the inadequate methods
available to manage and store the required cryptographic
keys~\cite{Kher2005}. Custos aims to solve the key-storage problem
inherent in many modern applications of cryptographic security. In
doing so, it strives to enable a variety of new use cases and data
security paradigms not readily available today.

\subsection{Separating Functionality from Trust}

Data security is an issue of trust. Who do we trust to access our
data? Who do we trust not to misuse it? Who do we trust not to share
it without permission? Today, we have very little practical ability to
make decisions regarding who we should trust with our data. Do you
want to use Facebook to communicate with family and friends? Great,
but you must trust Facebook with your personal data. Want to use Gmail
for its sleek web interface and cloud-based accessibility? Fine, but
you must trust Google with all of your email and contacts. Sure, you
could forgo using Facebook or Google or any of a wide variety of web
services to avoid trusting them with your data, but as you drift toward
the hermitage of self-imposed digital exile, the last of your former
friends slowly fading from memory as they cease to even recall your
existence absent their normal methods of web-based contact, fumbling
through the vestigial pages of a phone book vainly hoping to find a
number for someone's cell phone that has never, and will never, be
listed there, you may decide that giving up control over whom you
trust with your data is a perfectly fair price to pay to rejoin the
21st century land of living, breathing, digitally-exposed souls.

And even if you could live without modern cloud-based services, using
good old fashioned computing technology still involves placing trust
in systems or parties beyond your full control. Do you trust your
computer manufacture not to have installed a hardware key logger that
sends data to a variety of their ``business partners''? Do you trust
your operating system not to have a government-mandated back door for
covert access by the local constabulary?  Do you trust yourself not to
lose your laptop, exposing all of the data on it to whomever might
find it?

\begin{figure}[!tb]
  \vspace{5ex}
  \begin{center}
    \begin{subfigure}{.32\textwidth}
      \begin{center}
        \includegraphics[height=200pt]{./figs/pdf/TrustModel-Traditional.pdf}
        \caption{Traditional}
        \label{fig:trust-traditional}
      \end{center}
    \end{subfigure}
    \begin{subfigure}{.65\textwidth}
      \begin{center}
        \includegraphics[height=200pt]{./figs/pdf/TrustModel-Seperated.pdf}
        \caption{Separated}
        \label{fig:trust-seperated}
      \end{center}
    \end{subfigure}
  \end{center}
  \caption{Evolving Trust Models}
  \label{fig:trust}
\end{figure}

Here is the crux of the problem: in order to benefit from many of the
modern features and amenities of the digital world, you must pay the
entry price of deference of trust to organizations, technologies, and
individuals beyond your direct control whether you would like to or
not (Figure \ref{fig:trust-traditional}).

So how can we solve this problem? How can we eliminate this disconnect
between the services we desire and the trust we'd prefer not to cede?
It seems unlikely that we can eliminate trust from the equation all
together. Systems are too fragile and technology too tied to human
action; we will always require some level of trust in some part of the
systems we rely on.

While we might not be able to remove trust, what if we could at least
isolate it? Separate trust from features. Disentangle what we use from
who we trust. What if we could have one company we trusted with
controlling access to our data and another company we relied on to
access controlled subsets of our data and provide us with a useful
service using it: the ability to use Facebook or Google without
trusting (or at least unrestrictedly trusting) Facebook or Google
(Figure \ref{fig:trust-seperated}).

With such an ecosystem, we might be able to rely on open markets or
similar means to provide us with the basic platform for securing our
data. Trustworthiness would become a service; a commodity to be bought
and sold. We could chose and pay the companies responsible for
securing our data based on their level of trustworthiness, while
choosing and paying the companies that use our data to provide us with
relevant features on the basis of the features they provide. This
would remove the current coupling of features and trust we see today,
a coupling that often leads to a conflict of interest between the
features we desire and the trust we're willing to
provide~\cite{Flowerday2006}. Instead we'd assign trust on the basis
of perceived trustworthiness while selecting untrusted services on the
basis of feature sets; the trusted party acting as a gatekeeper
between the untrusted party and our data. We could even distribute
trust across multiple parties to avoid having to trust any single
party completely, paying each party on the relative merit of their
perceived trustworthiness and security. Such a decoupling of trust and
services would provide a lot of flexibility to maximize both the
security and the utility of our data.

\subsection{The Importance of Usability}

Strong encryption provides the basis for a system of separating trust
from features. With it, we can lock-down our data, rendering it
unusable to all but those to whom we grant access. Once data has been
encrypted, access to the data ciphertext itself need no longer be
granted or denied on the basis of trust. The ciphertext can be exposed
to the world confident in the knowledge that it will be indecipherably
useless without also having access to the corresponding encryption
keys. But if encryption is the lock we place on our data, then trust
becomes a matter of to whom we grant the keys. Unfortunately, while
encryption itself may be easy and well understood, securely storing,
managing, and utilizing encryption keys is hard.

It is the key management challenges that leads to many of the known
usability problems with modern encryption systems~\cite{Whitten1999,
  Sweikata2009, Kher2005}. Modern encryption systems tend to be
inflexible. They force the user into a pre-defined security paradigm
and use case. For example, today we use systems like
Dropbox~\cite{dropbox} or Google Drive~\cite{google-drive} to store
and sync our files across a range of computers and mobile devices, but
key management limitations mean that few existing encryption schemes
support this kind of multi-device access. When we wish to transfer and
share files, we often do it via e-mail attachments or removable media,
but these forms of ``out-of-band'' sharing are not supported by most
existing key management and data encryption systems. Many of our
modern (and legacy) computing services are designed to run in the
background, devoid of interactive input, but many existing encryption
solutions rely on authentication primitives that require interactive
input in order to securely access encrypted data.

Most modern encryption systems are built around a ``one size fits
all'' mentality, leaving the user with very little flexibility to
control the manner in which her encrypted data might be accessed,
used, or shared. Nor do such systems acknowledge the fact that not all
encrypted data need be protected with the same level of security. Some
data, like social security numbers, must be shared with a multitude of
3rd parties. Other data, like personal photos, should be shared, but
only with specific friends or family members. Still other data is
completely private, and should never be shared at all. The user knows
how sensitive each piece of data is, and how it should be used, but
most encryption systems fail to expose a flexible method for allowing
the user to protect data on the basis of sensitivity and desired use.

\begin{figure}[!tb]
  \vspace{5ex}
  \begin{center}
    \begin{subfigure}{\textwidth}
      \begin{center}
        \includegraphics[height=200pt]
                        {./figs/pdf/SecuityToAccessibility-Traditional.pdf}
        \caption{Traditional Fixed Balance}
        \label{fig:SvA-traditional}
      \end{center}
    \end{subfigure}
    \begin{subfigure}{\textwidth}
      \begin{center}
        \includegraphics[height=200pt]
                        {./figs/pdf/SecuityToAccessibility-Custos.pdf}
        \caption{Custos's Flexible Balance}
        \label{fig:SvA-custos}
      \end{center}
    \end{subfigure}
  \end{center}
  \caption{Balancing Security vs Accessibility}
  \label{fig:SvA}
\end{figure}

It is often said that security and accessibility are at odds. That one
can not be improved except at the expense of the other, and that this
fact makes secure systems inherently challenging to use. While I do
not believe that security vs accessibility is truly a zero sum game,
there is some truth to the fact that security and accessibility are
often at odds. Security and accessibility exist on a continuum, with
fully accessible, minimally secure systems on one side, and minimally
accessible, highly secure systems on the other. Many will say that
this inherent security vs accessibility trade-off means that secure
systems will never be easily usable. But it is not this security vs
accessibility trade-off that leads to usability issues. Rather it is
the fact that many secure systems lock the user into a specific point
on the security vs accessibility spectrum that causes usability
problems (Figure \ref{fig:SvA-traditional}). Such inflexibility forces
a user to surmount unnecessary hurdles and forgo certain ease of
access for data that need only be minimally secure while also denying
users the means to fully secure highly sensitive data. This mismatch
between user requirements and system capabilities is a sure recipe for
usability challenges.

The inability of existing encryption systems to accommodate a diverse
range of use cases and to grant the user the flexibility to properly
place various pieces of data at various points on the security vs
accessibility spectrum leads to such systems being very difficult to
use. Fortunately, this inflexibility is not due to the underlying
encryption itself, but to the inadequate methods by which encryption
keys are managed and stored. Today, most data encryption solutions
tightly couple key storage with the underlying encryption system. This
is a mistake that has lead to a growing usability gap, and the
corresponding underutilization, of encryption as a tool for securing
and controlling our data. If encryption is going to provide a
mechanism for controlling access to our data, it needs a flexible key
storage and access control mechanism (Figure \ref{fig:SvA-custos}).

\subsection{Secret Storage as a Service}

I propose separating key storage and access management from the
underlying encryption systems through a ``Secret Storage as a
Service'' architecture: a dedicated system for securely storing and
providing access control to user-provided secretes. When the provided
secrets are encryption keys, this service would become a ``Key Storage
as a Service'' system. Such a service can make encryption systems far
more flexible and accommodating of the diversity of modern use cases,
and by extension, can make encryption far easier to use. Separating
key storage from encryption also enables the separation of trust from
functionality, allowing users to select providers for each on the
basis of their relative merits. Strong encryption is one of the best
available tools for securing and protecting our data. I wish to
reclaim it as a viable option for controlling our data in environments
that are increasingly outside of our control. I wish to use encryption
to secure our data, while designating trusted Key Storage as a Service
providers to control access to it based on my specifications.

In a Key Storage as a Service architecture, the underlying encryption
systems delegate key storage and access control to a separate service
instead of embedding these features directly. The key storage platform
exposes a common API, capable of being used with a variety of
encryption services. Encryption services tag encrypted data with a
unique ID, and then store this ID and the corresponding encryption key
with a key storage provider. When a system wishes to decrypt data, it
queries the key storage service for the encryption key corresponding
to the data's ID tag, and, assuming the system can satisfactorily
authenticate to the key storage service and has permission to access
the requested key, the key storage service returns the encryption key
allowing the service to decrypt the data. This separation of
encryption system and key storage allows for multiple encryption
systems, or multiple instances of an encryption system, to all access
a centralized key store. It also allows encryption systems to focus on
encryption, while key storage systems can focus on the non-trivial
implantation of secure of key storage, access control, and auditing.

\section{Background}

Custos builds on a number of existing technologies and systems: from
basic encryption systems to authentication systems to protocol and
systems design principles. In some cases these technologies form the
basis of the Custos architecture; in others, Custos is a direct
reaction to the existing limitations of these systems.

\subsection{Encryption}

Modern digital encryption systems come in two flavors: symmetric and
asymmetric encryption. Symmetric encryption algorithms use the same
key to both encrypt and decrypt data. Asymmetric systems use two keys;
when one key is used to encrypt the data, the other can be used to
decrypt it, and vice versa. Both encryption systems have a place in
the modern security landscape: symmetric systems for their high
resistance to cracking and quick encrypt/decrypt performance, and
asymmetric systems for their avoidance of the key exchange problem,
making them the basis of modern public-key cryptography
technologies~\cite{Menezes1996}.

Symmetric encryption ciphers like AES (Rijndael)~\cite{Daemen1999},
Twofish~\cite{Schneier1998}, or Camellia~\cite{Matsui2004} are
well-established, fast, and secure methods for encrypting
data. Symmetric encryption ciphers use a single key for both
encryption and decryption. This key must be securely stored, or if
shared, securely exchanged between parties. Anyone with the key can
decrypt the corresponding ciphertext the key was used to
create. Symmetric encryption systems are the preferred means of
encrypting files, hard disks, and other large chunks of data due to
their speed and relative simplicity of implementation. They tend to be
well understood, and are generally considered highly secure. The
security of a symmetric encryption cipher tends to be directly related
to the length of the encryption key: the longer the key, the more
secure the data encrypted with it is. Common key lengths generally
considered secure today include 128-bit keys, 256-bit keys, and
512-bit keys.

Asymmetric encryption systems, unlike symmetric encryption systems,
rely on two keys: when one key is used to encrypt the data, a second,
related key is used to decrypt the data. This two key system makes
asymmetric encryption ideal for sharing encrypted data: one key is
publicly released, the other key is privately kept secret. Anyone can
use the public key to encrypt data that only you can decrypt using
your private key. Prime-factorization-based asymmetric encryption
systems like RSA~\cite{Rivest1978, NIST2001} form the basis for modern
public-key cryptography systems. Asymmetric ciphers tend to be slower
and more complex than symmetric ciphers. Like symmetric ciphers, the
security of an asymmetric cipher is related to the length of the keys
in a key pair: longer keys are more secure. Standard key lengths for
asymmetric keys (or at least those used by common factorization-based
encryption system) tend to be an order of magnitude larger than
asymmetric keys due to the more easily cracked nature of asymmetric
key generation. Key lengths of 1024-bits, 2048-bits, and 4096-bits are
all common.

Often symmetric and asymmetric cryptography are used together, each
system playing to its strength. Symmetric ciphers are good at quickly
and securely encryption data, making them appropriate for the core of
an encryption system. Symmetric ciphers, however, suffer from a lack
of natively secure method for exchanging the required encryption
key. This is where asymmetric cryptography and related secure key
exchange systems like Diffie-Hellman~\cite{Diffie1976} come in
handy. Since these systems provide the basis for securely exchanging
data over insecure channels, they can be used to exchange the
symmetric encryption key actually used to encrypt the underlying
data. Such systems are common in many modern protocols like
SSL~\cite{Freier2011}, TLS~\cite{Dierks2008}, and
OpenPGP~\cite{Callas2007, openpgp}.

Custos uses and supports a variety of the above technologies. In
general, we believe that Custos will primarily be used to store
symmetric encryption keys, due to symmetric ciphers core place in data
encryption. It is also symmetric keys that require the most management
since they lack a built-in secure exchange method. Custos, however,
leverages asymmetric technologies like TLS to implement the secure
exchange of the stored symmetric encryption keys and related
authentication data. Custos is also perfectly capable of storing
asymmetric keys in systems like SSH where centralized asymmetric key
management is beneficial. Custos aims to improve upon existing systems
for managing and exchanging encrypted data (e.g. OpenPGP) by providing
more flexibility, extensible, and thus better usability than such
system normally afford.

\subsection{Human Factors}

Security research and human factors research have not always been kind
bedfellows. Fortunately, the last 15 years have seen a rise in human
factors research related to the usability of security products and
systems. This research has served to underline the growing
understanding that security without usability isn't really security at
all. If users refuse to utilize security systems because they are too
much of a burden, or if they incorrectly use them due to lack of
understanding, the security such systems provide is largely
useless. The growing awareness of usability concerns related to
security systems has led to an increased effort to build systems that
are both secure and usable. Usability with respect to a security
system like Custos comes in three flavors: usability of the
applications leveraging Custos, usability of Custos itself when
administering data access requirements, and the usability of the
Custos interface by developers wishing to integrate their applications
with Custos.

The end-user usability of existing encryption systems is one of the
more commonly studied security and usability domains. One of the
pinnacle works in the field, ``Why Johnny Can't
Encrypt''~\cite{Whitten1998, Whitten1998}, discusses the usability
challenges of public-key cryptography systems, in particular
PGP~\cite{openpgp}. The work discusses both UI issues related to the
PGP GUI, as well as more fundamental difficulties like the fact that
security is normally a secondary user objective, making it difficult
to convince users to put effort into attaining it. More recent
work~\cite{Furnell2006, Furnell2006a, Furnell2010, Ibrahim2010,
  Sweikata2009} expands on these concepts, highlighting the complexity
often involved in performing key management and in fitting
cryptographic systems to existing usage patterns. The widespread
consensus is that existing encryption systems are difficult to use,
not well matched to modern user desires, and often ignored in favor of
simpler, less secure, options.

Custos is also concerned with usability from a management
perspective. Configuration errors are a well known source of security
holes~\cite{Bishop1996, kerravala2002configuration}. A good
configuration system tends to be logically
centralized~\cite{Casado2007}, easily manipulated, and provide direct
mental mappings between user intent and configuration
parameters~\cite{norman2002design}. Custos strives to address these
issues and help ensure a valid mapping between a user's intention and
the associated actualization of this intention.

The third usability point Custos hopes to address involves the
usability of Custos as an interface. How easy is it to integrate
Custos into existing applications? How easy is it to manage Custos via
a variety of front ends? There is less formal research available on
the usability of programming interfaces and APIs. That said, industry
best practices would suggest that a usable interface follows standard
design patterns (e.g. RESTful~\cite{ibm-restful}), utilizes standard
data formats (e.g. JSON~\cite{json}), and maximizes capability while
minimizing unnecessary complexity (the KISS principle).

\subsection{Authentication Systems}

Over the years, we have developed a range of authentication techniques
and protocols. The goal of any authentication system is to confirm the
validity of a fact. In many authentication systems, the fact they aim
to confirm is the positive association between a user's asserted
identity and the user's actual identity. In short: is an actor who she
claims to be? Authentication systems can also be used to verify the
association between an actor and an object (i.e. does a user process
access to a specific token or device), between an actor and a
capability (i.e. as in a CAPTCHA~\cite{captcha}), or between a variety
of more generalized facts and associations. Authentication and
authorization are often complementary systems. Authentication is used
to establish the identity of an actor. Authorization then leverages
this identification as the basis of granting or denying specific
rights to the actor.

Early computer authentication schemes often revolved around the use of
a single basic primitive: text-based passwords. To this day, passwords
are probably the most common authentication primitive. Passwords are a
form of shared secret. They operate on the premises that only a
specific actor and the system with which she wishes to interact will
be aware of the value of a unique text token. When the actor wishes to
prove her identity, she provides her password to the system, which
confirms that it matches the expected password. Often, instead of
comparing passwords directly, passwords are first hashed before being
stored. Hashing provides some measure of security against attackers
wishing to brute-force a leaked password list. Hashing operates by
dissociating the provided password value from the stored password
value via a one-way hash function. Passwords are often used in an
interactive manner, where an actor must provide her password at a live
prompt. But passwords can also be used in non-interactive (albeit
generally less secure) forms where the necessary password is simply
stored and automatically provided when required. Passwords, while
common, have a range of known limitations and issues. From reuse, to
guess-ability, passwords have a lot of
problems~\cite{goodin-passwords, goodin-bible, Mazurek2013,
  Singer2013}. None the less, they remain ubiquitous authentication
primitives to this day due to their ease of use and user familiarity.

In addition to passwords, common authentication primitives also
include asymmetric cryptography certificates, multi factor devices,
biometrics, and contextual information. Systems like
OpenSSH~\cite{openSSH} and OpenPGP~\cite{openpgp} support using
standard asymmetric cryptography certificates as the basis for
authentication. In such systems, an actor's public key is stored by
the server. The user must prove they have access to the corresponding
private key, often by decrypting a message encrypted with their public
key, in order to authenticate. Certificate based authentication
systems have the benefit of often being non-interactive; the user must
simply posses the necessary certificate to gain access, no interactive
password prompt required. They also tend to be far more resistant to
brute-force attacks given the superior entropy of long,
randomly-generated certificates over short, human-generated passwords

Multi factor authentication systems are rising in popularity as a
mitigation tactic for the risks of password based authentication
systems. Such systems force the user to prove they have access to an
object (often a cell phone~\cite{google-auth} or USB
dongle~\cite{yubikey}) in addition to prompting the user for their
password or related primitive. Where as a password is ``something you
know'', a multi factor device is ``something you have'', the
combination of which make up the multiple factors in ``multi-factor''
authentication.

Biometric authentication systems have also become more common. Many
modern laptops and cell phone include fingerprint readers, and more
exotic devices like retina or palm scanners are not uncommon in
high-security installations. Systems have even been proposed that rely
on a user's unique keystroke patterns to identify
her~\cite{Peacock2004}. There are also a variety of contextual
authentication systems, that aim to authenticate the user on the basis
of various environmental data available when the user wishes to
authenticate (i.e. IP address, time of day,
etc)~\cite{Hulsebosch2005}. Such systems often provide a secondary
authentication mechanism beyond a primary mechanism like a password or
certificate.

Moving beyond basic authentication primitives, there are also a range
of existing authentication protocols and
standards. Kerberos~\cite{Kohl1994, Neuman1994} was an early and
widely deployed authentication system. It aims to provide secure
authentication over untrusted networks, as well as to allow
token-based single-sign-on access across multiple sites and
services. Kerberos is still used widely today as part of the Microsoft
suite of operating systems and in a number Linux and Unix
environments. Similarly, SAML (Security Assertion Markup
Language)~\cite{saml}, SASL (Simple Authentication and Security
Layer)~\cite{sasl} are standardized formats for exchanging
authentication and authorization data. SAML is the basis of
authentication systems like Shibboleth~\cite{shibboleth, Leandro2012}
whose aim is to create a standardized federated authentication system
for use across the Internet. Systems like OAuth~\cite{oauth},
OpenID~\cite{openid}, or Persona~\cite{persona} operate under a
similar principle, allowing users to designate a federated Cloud-based
identity providers who can be used to authenticate the user to a range
of disparate web services.

PAM~\cite{linux-pam, openpam} is a framework for integrating a variety
of authentication primitives and systems in an application. PAM is
used by Linux and a variety of other POSIX operating systems as the
basis for a flexible user login authentication system. PAM exposes a
standardized API for integrating various authentication technologies
into the a generalized authentication framework.

Custos aims to be flexible enough to incorporate a range of existing
authentication primitives and systems based on the user's
requirements. Custos also incorporates ideas from PAM related to the
pluggability of authentication modules. The details of these points
are discusses in subsequent chapters.

\section{Related Work}

Custos is not the only system trying to simplify encryption and
provide a solution to the key storage problem. A number of other
systems have been created with similar goals, albeit often different
approaches. From existing secure storage systems, to secret managers,
to consumer cryptographic suites many individuals have proposed
possible ways to make encryption more usable and data more easily
secured.

\subsection{Secure Storage}

Early storage and file system technologies often simply neglected
security, lacking robust encryption and access control primitives.
Fortunately, today there are a variety of secure storage systems
available. Some of them are full stack systems that bundle security,
distribution, and sharing in a single system. Others are layered
systems, designed to add security atop existing lower level file
storage technologies. All of them have limitations that Custos strives
to overcome.

Many modern storage systems include cryptographic security as part of
their design. Such full stack systems bundle cryptography, distributed
usage, data storage, and other features into a single
package. Traditional network storage systems like
NFS~\cite{Sandberg1985} or AFS~\cite{Howard1988} provide support for
encrypting data as it travels over the network, but lack support for
encrypting data at rest, requiring users to fully trust the system on
which their data is stored or cached. Systems like
RFS~\cite{Dong2011}, Keypad~\cite{Geambasu2011}, or
CryptoCache~\cite{Jensen2000} are optimized for modern mobile device
usage, and include features like encryption at rest, auditing, and
multi-device support. Unfortunately, these systems lack support for
multi-user sharing. Systems like OceanStore~\cite{Kubiatowicz2000} or
Tahoe~\cite{Wilcox-O'Hearn2008} deal with securing data atop untrusted
infrastructure, and include primitives for securely sharing and
distributing files amongst users. These systems, however, lack support
for the kinds of out-of-band (e.g. emailing files, transferring files
on thumb drives, etc) sharing and syncing that are so common and
natural today. In general, full stack systems are only useful if you
are willing and able to utilize them as the entirety of your storage
stack, and are not easily extended or combined with other
technologies.

Other modern secure storage systems follow in the Unix tradition of
layered file systems, where each layer provides only a single function
(e.g. redundancy, encryption, storage, etc). Systems like
LUKS~\cite{luks} or eCryptfs~\cite{eCryptfs, Halcrow} are popular,
widely deployed, layered encryption systems. They are capable of
operating atop a variety of underlying file systems and are thus well
suited for use on personal computers. Most of these systems, however,
are not well suited for supporting secure multi-device syncing or
secure multi-user sharing.

All of the above systems, however, suffer from the traditional
entanglement of key management and the underlying encryption. As we
stated in the previous section, conflating these two items is to
conflate policy and mechanism, a well known sin in usable and
maintainable systems design~\cite{Wulf1974}. The bundling of key
storage with the underlying encryption leads to a lack of flexible key
management and access control capabilities. I am not the first to
recognize this barrier. The SFS~\cite{Mazieres1999} file system was
designed to separate key management from file storage, allowing for
more flexible key management in the process. Likewise,
Plutus~\cite{Kallahalla2003} strives toward separating key storage and
access control from the underlying encryption. But both SFS and Plutus
fail to fully define a standardized, generic, and flexible external
system for storing and managing keys, making a true ``Key Storage as a
Service'' architecture impossible to realize.

\subsection{Password and Secret Mangers}

Password and secret managers represent a class of software designed
for securely storing user secrets. In the age of
every-website-needs-a-password and constant prompting for personal
info like credit card (CC) numbers or social security numbers (SSNs),
these systems provide the user with a method for managing their
secrets in a centralized, secure location.

Password mangers like 1Password~\cite{onepassword},
LastPass~\cite{lastpass}, or Apple's iCloud Keychain~\cite{icloud}
provide users with a single repository for storing website
credentials. These services often integrate with web browsers to allow
users to atomically populate password and user name fields and log
into the websites. Many modern web browsers (i.e. Google
Chrome~\cite{google-chrome}) even include password management
functionality built in. Password managers aim to increase user
security by allowing users to use a range of unique, complex passwords
without the added burden of having to memorize a separate password for
every site. While they do create a single-point-of-failure, most
security researchers believe using a password manager protected by a
strong master password and multi factor authentication is more secure
than using weak, repetitive passwords across multiple
websites~\cite{schneier-passwords, krebs-passwords, brodkin-passman}.

Many password managers are also capable of storing common user data
like SSNs, CC numbers, addresses, and birth dates and filling this
information into website forms that require it. While password
managers do tend to be a good mechanisms for managing passwords and
user data, they still require a lot of direct user intervention
(creating passwords, filling form fields, etc). They generally lack
standardized interfaces for directly interacting with services
requiring user credentials, instead simply using browser extensions to
copy and paste data into the fields where a user would normally type
it. They also tend to lack support for arbitrary authentication
mechanisms. Nor do they provide a good system for data sharing or
multi-user access. They are often associated with propriety companies,
making it difficult to move data from one to another and forcing the
user to trust the specific company providing the service, violating
the Custos principal of separation of features and trust.

Moving beyond password managers, others have proposed generic secret
storage services (i.e. Key Storage as a Service) similar to Custos.
CloudKeep~\cite{cloudkeep-presentation, cloudkeep} is a Rackspace
project that aims to create a standardized key and secret storage
system, avoiding the need to re-implement such systems across each
application and providing centralized access control and
auditing. Custos shares similar goals. CloudKeep, however, lacks the
fully generic flexibility of Custos, prescribing a more specific usage
model than Custos requires. A variety of private companies also
provide similar services (i.e. Gazzang~\cite{gazzang}). These systems,
however, are propriety, closed, and not easily extensible. They also
lack the generic flexibility of Custos's authentication and access
control mechanisms.

\subsection{Cryptography Suites and Key Escrow Systems}

Consumer-oriented cryptography suites exist to make encryption easier
for the end-user. Unfortunately, as we discussed in previous sections,
many of these systems have series usability constraints. None the
less, they do exist as end-user targeted cryptography applications,
and thus share Custos's goal of making encryption available to end
users.

OpenPGP~\cite{openpgp} is likely the most well known user cryptography
suite. It provides tools for leveraging asymmetric cryptography to
encrypt, decrypt, sign, and verify data or messages. On the propriety
software front, the most common OpenPGP implementation is Symantec's
PGP~\cite{pgp}. It is the evolution of the original PGP software suite
and provides users with a GUI, email client plugin, and CLI for
utilizing OpenPGP. On the open source side, GnuPG~\cite{gnupg} is by
far the most commonly used OpenPGP utility. Like PGP, it provides
users with a CLI for preforming OpenPGP operations. There are a number
of third-party front-ends for GnuPG enabling GUI-based usage and mail
client integration. All of these systems, however, lack a standardized
solution for key storage, offloading the burden of protecting private
keys to the user.

OpenPGP's most common use is to send and receive secure email. Toward
this end, a variety of mail clients exist to enable easy use of
OpenPGP when sending or receiving mail. Systems like the
Enigmail~\cite{enigmail} GnuPG Thunderbird add-on or the default PGP
mail client plugin provide users with direct access to OpenPGP
functions from within their mail clients. Some mail clients like
Mailpile~\cite{mailpile} integrate OpenPGP support directly,
emphasizing end-user usability of encrypted email. While these systems
are commendable for striving to make encrypted messaging more
accessible to end users, they suffer from the same ``ignore key
management problem'' that the underling OpenPGP tools they use
exhibit. To overcome this shortcoming, research systems like
STEED~\cite{Koch2011} attempt to expand on the basics of PGP to better
secure user email in a more usable manner. Still, all of these systems
are very specific encryption solutions, pertaining only to sending and
receiving secure email. They do not broach the larger issue of making
encryption available to users across a range of arbitrary use cases.

Custos is not the first system to propose moving key storage to a
separate third party. Key escrow systems have long used a similar
approach~\cite{Blaze1996, Denning1996}, specifying dedicated third
parties for key storage. Most key escrow systems are designed for
backup, regulatory, or administrative reasons. Thus, they often
decrease serve to decrease encryption-system security in the spirit of
administrate overrides or regulator requirements. Custos, on the other
hand, aims to use dedicated key storage entities to increase end-user
security.

%%  LocalWords:  Mailpile Diffie CryptoCache Plutus LastPass iCloud
%%  LocalWords:  CloudKeep Rackspace Gazzang Symantec's Enigmail AFS
%%  LocalWords:  Custos Custos's OceanStore SFS
