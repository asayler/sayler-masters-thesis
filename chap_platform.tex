\chapter{Platform}
\label{chap:platform}

In chapter \ref{chap:intro}, I explained the motivations behind
Custos. Chapter \ref{chap:purpose} outlines the design goals and
potential applications that these motivations suggest. In this
chapter, I'll discuss the architecture, interface, and implementation
of Custos platform.

\section{Architecture}

The Custos architecture contains several core components:

\begin{packed_item}
\item A standardized API and message exchange format
\item A server-side authentication plugin interface supporting a range
  of authentication primitives
\item A server-side access control system for protecting stored data
\item A server-side back-end key:value object store for holding
  persistent data
\item A server-side data access system for coordinating the storage
  and retrieval of user data
\item A server-side auditing system for monitoring key:value
  authentication and access
\item A server-side management system for configuring and controlling
  the other components.
\item One or more client applications that offload objects to a Custos
  server for storage.
\end{packed_item}

\begin{figure}[!tb]
  \vspace{5ex}
  \begin{center}
    \includegraphics[width=.75\textwidth]
                    {./figs/out/Arch-Overview.pdf}
  \end{center}
  \caption{Basic Components of the Custos Architecture}
  \label{fig:arch-overview}
\end{figure}

Figure \ref{fig:arch-overview} shows the core Custos components. The
bulk of core Custos functionality is handled on the server side. The
server is designed to expose a single standardized API in order to
allow for a variety of inter-compatible implementations (one possible
implementation is discussed below). The Custos server implements the
following components:

\begin{packed_desc}
\item[API] \hfill \\ The server API handles all Custos requests,
  including requests for key:value objects, requests to audit data
  access, and requests to modify data access controls. The API is
  essentially an RPC interface to allow applications to make requests
  of the Custos service.
\item[Access Control Subsystem] \hfill \\ The access control subsystem
  is the first step in the request processing pipeline after the
  API. The access control system compares the provided authentication
  attributes (calling into the authentication subsystem to verify
  them) to the set of required authentication attributes to determine
  if a Custos request should be allowed or denied.
\item[Authentication Subsystem] \hfill \\ The authentication
  subsystem's job is to verify the validity of any authentication
  attributes associated with a given Custos request. This subsystem
  provides a pluggable authentication module interface capable of
  supporting a variety of authentication attributes.
\item[Data Subsystem] \hfill \\ The data subsystem is responsible for
  handling verified and accepted Custos data API requests (get, set,
  create, and delete key:value objects).
\item[Auditing Subsystem] \hfill \\ The auditing subsystem is
  responsible for handling verified and accepted Custos audit API
  requests. The auditing subsystem is also concerned with logging all
  Custos requests and their corresponding responses. This data can
  then be used to generate reports related to the 'who', 'what', and
  'why' questions: \emph{Who} accessed (or failed to access)
  \emph{what} Custos stored data and \emph{why} were they granted or
  denied access (e.g. what authentication attributes did they present
  and were able to verify).
\item[Management Subsystem] \hfill \\ The management subsystem is
  responsible for handling all management related API requests after
  they have passed the authentication and access control layers. This
  primarily entails manipulating access control parameters.
\item[Key:Value Store] \hfill \\ The Key-Value store is the persistent
  data container associated with a given Custos server. It is used to
  store both end-user key:value objects (encryption keys, etc) as well
  as a variety of internal Custos state (access control requirements,
  etc).
\end{packed_desc}

A Custos client applications interacts with a Custos server via the
API. As such, a client can simply offload the its secrets (encryption
keys, etc) and access control duties directly to Custos through
API-backed RPC libraries. Custos simply becomes a remote key:value
database where application secrets are stored. To satisfy Custos's
authentication requirements, applications can generate the necessary
authentication attributes directly or can instead pass these
requirements on to the user, querying them for the necessary
attributes to send to Custos. Applications can either implement
auditing and management support directly using the management
components of the Custos API, or applications can pass off auditing or
management duties to separate dedicated management applications that
interact with Custos directly.

\section{Access Control}

As I already mentioned, the key:value abstraction Custos presents for
storing secrets is fairly well understood. It is Custos's access
control abstraction that is unique. This abstraction is at the core of
Custos's flexible capabilities.

\begin{figure}[!tb]
  \vspace{5ex}
  \begin{center}
    \includegraphics[width=.75\textwidth]
                    {./figs/out/Arch-OU.pdf}
  \end{center}
  \caption{Custos's Organizational Units}
  \label{fig:arch-ou}
\end{figure}

In order to discuss the access control abstraction, I must first
explain the Custos \emph{organizational units} (OUs: the core Custos
data structures). The Custos architecture specifies three
organizational units (Figure \ref{fig:arch-ou}): a server, a group,
and a key:value object. The server unit is used to specify server-wide
configuration. A server has one or more groups. A group is used to
slice a server between a variety of administrative domains. It exists
to allow a single server to grant group-level administrative
privileges to multiple, non-cooperating entities (i.e. separate Custos
customers). A group, in turn, has any number of actual key:value
objects stored within it. Each OU is responsible for the creation of
OU instances beneath it, e.g. servers create groups and groups create
objects.

\begin{figure}[!tb]
  \vspace{5ex}
  \begin{center}
    \includegraphics[width=.75\textwidth]
                    {./figs/out/Arch-ACS.pdf}
  \end{center}
  \caption{Custos Access Control Specification Components}
  \label{fig:arch-acs}
\end{figure}

The Custos access control abstraction revolves around designating an
\emph{Access Control Specification} (ACS) for each OU in the Custos
architecture. An ACS consists of three components (Figure
\ref{fig:arch-acs}). First, each ACS contains a full list of the
applicable Custos \emph{permissions} for the given OU. Associated with
each permission is one or more \emph{access control chains}
(ACCs). Each ACC consists of an ordered list of \emph{authentication
  attributes}.

\subsection{Permissions}

The Custos access control model starts with the concept of a
permission: a right to perform a specific Custos action. Custos has
specific permissions associated with each OU: per-server permissions
(Table \ref{tab:permissions-server}), each associated with the
top-level Custos server, per-group permissions (Table
\ref{tab:permissions-group}), each associated with a specific server
group, and per-object permissions (Table
\ref{tab:permissions-object}), each associated with a specific
key:value object within a group. The first three letters of a
permission name indicate the type of OU with which it is associated:
\texttt{srv}:server, \texttt{grp}:group, or \texttt{obj}:object. The
ACS for a given OU contains all permissions related to that OU.

Custos permissions are generally associated with the three core Custos
subsystems based upon the subsystem handling the associated actions
the permission grants: data access, auditing, and management. The
Custos data access permissions follow the pattern used by many data
access systems: permission to read data, permission to write data,
permission to create data, and permission to delete data. Likewise,
Custos associates audit permissions with various entities. Audit
permissions grant read and delete access to various audit data.
Finally, the Custos management permissions control a user's ability to
manage a specific Custos OU. This includes the ability to manipulate
OU access control specifications and to create lower-level OUs. Unlike
many systems, Custos has no notion of object ownership. Instead, it
relies on providing access to each right an owner would traditionally
hold via explicit permissioning.

Custos group and server ACSs also include an ``override''
permission. This permission can be used to override the permissions of
a lower-level OU's ACS. For example, anyone gaining the
\texttt{srv\_grp\_override} permission can use it to gain any of the
rights normally granted via a group-level permission. Likewise, anyone
gaining the \texttt{grp\_obj\_override} permission can use it to gain
any of the rights normally granted via an object-level
permission. These overrides exist for administrative tasks: allowing
server admins to manipulate group (and thus, also object) data, and
allowing group admins to manipulate object data. They must be used
with caution (or disabled), but they provide a powerful mechanism for
Custos administration.

Custos permission are initially set when the associated OU is
created. Part of the creation process involves passing Custos the
initial ACS definition for a new OU instance. After creation, The ACS
can be updated by anyone granted the necessary \texttt{acs\_set}
permission for the specific OU instance. This provides a flexible
mechanism for setting and changing permissions.

\begin{table}[!tbh]
  \vspace{1ex}
  \begin{center}
    \tabulinesep = 5pt
    \begin{tabu} to \textwidth
      { | X[1,l,m]
        | X[4,l,m]
        | }
      \hline
      \textbf{Permission}
      & \textbf{Rights}
      \\ \hline
      \texttt{srv\_grp\_create}
      & create groups on a Custos server
      \\ \hline
      \texttt{srv\_grp\_list}
      & list groups on a Custos server
      \\ \hline
      \texttt{srv\_grp\_override}
      & escalate to any group-level permission, overriding the per-group ACS
      \\ \hline
      \texttt{srv\_audit}
      & read all server-level audit information
      \newline
      (i.e. group creation logging, group override logging, etc)
      \\ \hline
      \texttt{srv\_clean}
      & delete all server-level audit information
      \newline
      (i.e. group creation logging, group override logging, etc)
      \\ \hline
      \texttt{srv\_acs\_get}
      & view the server-level ACS controlling the permissions in this list
      \\ \hline
      \texttt{srv\_acs\_set}
      & update the server-level ACS controlling the permissions in this list
      \\ \hline
    \end{tabu}
  \end{center}
  \caption{Per-Server ACS Permissions}
  \label{tab:permissions-server}
\end{table}

\begin{table}[!tbh]
  \vspace{1ex}
  \begin{center}
    \tabulinesep = 5pt
    \begin{tabu} to \textwidth
      { | X[1,l,m]
        | X[4,l,m]
        | }
      \hline
      \textbf{Permission}
      & \textbf{Rights}
      \\ \hline
      \texttt{grp\_obj\_create}
      & create a key:value objects within the given group
      \\ \hline
      \texttt{grp\_obj\_list}
      & list key:value objects within the given group
      \\ \hline
      \texttt{grp\_obj\_override}
      & escalate to any object-level permission, overriding the per-object ACS
      \\ \hline
      \texttt{grp\_delete}
      & delete the given group on a Custos server
      \\ \hline
      \texttt{grp\_audit}
      & read all group-level audit information
      \newline
      (i.e. object creation logging, object override logging, etc)
      \\ \hline
      \texttt{grp\_clean}
      & delete all group-level audit information
      \newline
      (i.e. object creation logging, object override logging, etc)
      \\ \hline
      \texttt{grp\_acs\_get}
      & view the group-level ACS controlling the permissions in this list
      \\ \hline
      \texttt{grp\_acs\_set}
      & update the group-level ACS controlling the permissions in this list
      \\ \hline
    \end{tabu}
  \end{center}
  \caption{Per-Group ACS Permissions}
  \label{tab:permissions-group}
\end{table}

\begin{table}[!tbh]
  \vspace{1ex}
  \begin{center}
    \tabulinesep = 5pt
    \begin{tabu} to \textwidth
      { | X[1,l,m]
        | X[4,l,m]
        | }
      \hline
      \textbf{Permission}
      & \textbf{Rights}
      \\ \hline
      \texttt{obj\_delete}
      & delete the given key:value object within the given group
      \\ \hline
      \texttt{obj\_read}
      & read the given key:value object within the given group
      \\ \hline
      \texttt{obj\_update}
      & create a new version of the given key:value object within the given group
      \newline
      (the equivalent of a ``write'' permission for the Custos write-once system)
      \\ \hline
      \texttt{obj\_audit}
      & read all object-level audit information
      \newline
      (i.e. object read logging, object update logging, etc)
      \\ \hline
      \texttt{obj\_clean}
      & delete all object-level audit information
      \newline
      (i.e. object read logging, object update logging, etc)
      \\ \hline
      \texttt{obj\_acs\_get}
      & view the object-level ACS controlling the permissions in this list
      \\ \hline
      \texttt{obj\_acs\_set}
      & update the object-level ACS controlling the permissions in this list
      \\ \hline
    \end{tabu}
  \end{center}
  \caption{Per-Object ACS Permissions}
  \label{tab:permissions-object}
\end{table}

\subsection{Access Control Chains}

Now that we've seen the available permissions contained in an ACS for
a specific OU, I can explain the next portion of an ACS: the access
control chains (ACCs). An access control chain is an ordered list of
authentication attributes. Each permission in an ACS has one or more
associated ACCs. In order for a request to be granted a specific
permission, it must be able to provide authentication attributes
satisfying at least one of the ACCs associated with that permission.

If a user wishes to disable access to a permission, they can do so by
associating the Null ACC with that permission. If the user want's to
provide unrestricted access to a permission, they may do so by
associating an empty ACC with the permission.

For example, consider a key:value object whose \texttt{obj\_read}
permission has the following ACC:

\begin{Verbatim}[samepage=true]
[ (username = 'Andy'), (password = '12345'), (ip_src = 192.168.1.0/24) ]
\end{Verbatim}

In order for my read request for the associated key:value object to
succeed, I would have to make sure that my request contained all three
of the above authentication attributes. That would mean attaching the
'username' attribute to the request with a value of 'Andy', as well as
attaching the 'password' attribute to the request with a value of
'12345'. The ip\_src attribute is an implicit attribute (see next
section) and will be automatically added to my request when received by
the Custos server. In order to satisfy it, I would have to send the
request from the local network attached to the Custos server I'm
trying to query.

Looking at a slightly more complex example, consider the same
\texttt{obj\_read} permission, but this time with two separate ACCs
associated with it:

\begin{Verbatim}[samepage=true]
[ (username = 'Andy'), (password = '12345'), (ip_src = 192.168.1.0/24) ]
[ (username = 'Andy'), (password = '12345'), (ip_src = 75.148.118.216/29) ]
[ (username = 'John'), (password = 'Swordfish') ]
\end{Verbatim}

Now I am able to make the Custos request from either the local network
or from my home IP range. As long as I can satisfy at least one ACC in
a set of ACCs for a given permission, I am granted the right to
perform actions associated with the permission. I have also granted
access to an additional user, John, with his own password and no
ip\_src restriction.

This system is highly flexible. Take, for example, the lack of
explicit username support anywhere in the Custos specification. As was
done above, usernames simply become another authentication
attribute. Often a username will be the first attribute in a ACC to
allow for all following attributes to be set relative to a given
username (as shown in the example above). But there's nothing special
about usernames. I could just have easily started each ACC with a
ip\_src, requiring a separate password based upon the location a user
is making their request from. The combination of simple ordered
attribute lists and a wide range of flexible attributes makes for a
very powerful access control system.

Another point worth noting is that sets of ACC lists can be converted
into sets of ACC trees, often simplifying the understanding or
verification of their intent. ACC lists are converted into ACC trees
by combining each attribute in matching attribute sub-chains across
multiple lists into single nodes in a ACC tree. For example, the
previous set of ACC lists could also be represented as:

\begin{center}
\begin{tikzpicture}
  \tikzset{level distance=30pt}
  \tikzset{sibling distance=0pt}
  \Tree [
    .\texttt{(username = 'Andy')}
    [ .\texttt{(password = '12345')}
      \texttt{(ip\_src = 192.168.1.0/24)} \texttt{(ip\_src = 75.148.118.216/29)} ]
  ]
\end{tikzpicture}
\begin{tikzpicture}
  \tikzset{level distance=60pt}
  \tikzset{sibling distance=0pt}
  \Tree [
    .\texttt{(username = 'John')}
    [ .\texttt{(password = 'Swordfish')} ]
  ]
\end{tikzpicture}
\end{center}

Finally, where desired, the Custos API can continue to prompt the user
for the next N missing attribute types in a chain. For now, N is a
per-implementation constant, but eventually N will be available as a
configuration parameter on a per-object basis. When N > 0, this
feature is leaking some authentication information in the form of the
required attribute types (although not their values), so it is left to
the user to decide when such leaking is acceptable and when it is
not. When in use, this feature allows a Custos server to engage in a
back-and forth with a client to prompt the client through all required
attribute types in an ACC. For example, in the case where N is equal
to 1, and the previously mentioned ACCs are in effect, the following
set of transactions would occur:

\begin{packed_enum}
\item The user sends a read object request with no attributes
\item The server respond that a username attribute is required
\item The user resubmits the request with an attached username
  attribute equal to 'Andy'
\item The server responds that a password is required
\item The user resubmits the response with a password equal to '12345'
\item As long as the user is submitting requests from either the local
  network or my home IP range, the server will respond granting the
  request.
\end{packed_enum}

But what happens when there are multiple next steps in an ACC? For a
more complex request-response example, consider the ACC expressed in
the following tree:

\begin{center}
\begin{tikzpicture}
  \tikzset{level distance=60pt}
  \tikzset{sibling distance=0pt}
  \Tree [
    .\texttt{(username = 'Andy')}
    \texttt{(password = '12345')} \texttt{(auth\_cert = '0x32C59C00')}
  ]
\end{tikzpicture}
\end{center}

In this ACC, I must either provide a password or prove access to an
authentication certificate. Rehashing the request-response sequence
from the previous ACC example:

\begin{packed_enum}
\item The user sends a read object request with no attributes
\item The server respond that a username attribute is required
\item The user resubmits the request with an attached username
  attribute equal to 'Andy'
\item The server responds that a password or an auth\_cert is required
\item The user resubmits the response with a password equal to '12345'
\item The server responds granting the request.
\end{packed_enum}

\subsection{Authentication Attributes}

Each Access Control Chain contains one or more Authentication
Attributes (AAs). An authentication attribute is a generic container
for authentication data. AAs contain the following information:

\begin{packed_desc}
\item[Class] \hfill \\ The class is the top level classification
  property of an AA. It is used to designate the nature of a given
  AA. Currently, Custos specifies two possible values for class:
  ``implicit'' and ``explicit''. Implicit attributes are those that
  are automatically associated with a request (like an IP address or
  SSL client certificate). Explicit attributes are those that the user
  provides directly to Custos (like a password or token).
\item[Type] \hfill \\ Within a given class, the AA type specifies which
  authentication plugin should handle a specific attribute. Details on
  currently supported Custos types are provided below.
\item[Value] \hfill \\ The value contains the arbitrary binary data
  associated with a given attribute. This could be a password, token,
  or portion of a handshake for more complicated authentication
  mechanisms.
\end{packed_desc}

The current Custos specification supports a handful of authentication
types. Thus far, the types support by Custos are primarily stateless
authentication mechanisms. This simplifies the design of the RESTful
interface and authentication plugins. That said, Custos eventually
intends to supports fully arbitrary authentication parameters,
allowing authentication plugins to maintain their own state across
requests where required. The currently defined implicit types are:

\begin{packed_desc}
\item[\texttt{ip\_src}] \hfill \\ The source IP of a request as seen
  by the Custos server (e.g. the gateway IP where NAT is in use,
  etc). Compared against the required
  \texttt{$\langle$base$\rangle$/$\langle$mask$\rangle$} specification
  where included.
\item[\texttt{user\_agent}] \hfill \\ The HTTP user agent
  associated with a given request. Compared against the required text
  value where included.
\item[\texttt{auth\_type}] \hfill \\ The HTTP authentication type
  associated with a given request (i.e. none, basic, digest,
  tls). Compared against the required type where included.
\item[\texttt{auth\_value}] \hfill \\ The HTTP authentication value
  associated with a given request. Often a username or some other
  identifying value output by the HTTP server's internal
  authentication mechanisms. Compared against the required value where
  included.
\item[\texttt{time\_utc}] \hfill \\ The time the request arrived in
  UTC. Compared against the
  \texttt{$\langle$base$\rangle$/$\langle$mask$\rangle$} UTC time
  specification where included.
\end{packed_desc}

\noindent
The currently defined explicit types are:

\begin{packed_desc}
\item[\texttt{user\_id}] \hfill \\ An arbitrary value. Directly
  compared against the required attribute value where
  included. Behaves the same as the \texttt{psk} type, but gets its
  own type name for readability of semantic intent.
\item[\texttt{psk}] \hfill \\ An arbitrary value. Directly
  compared against the required attribute value where included.
\item[\texttt{psk\_sha256}] \hfill \\ An arbitrary value. Hashed with
  the sha256 algorithm with the result compared against the the
  required attribute value where included. Specifications related to
  iterations and salting are specified on a per-site basis.
\item[\texttt{psk\_bcrypt}] \hfill \\ An arbitrary value. Hashed with
  the bcrypt algorithm with the result compared against the the
  required attribute value where included. Specifications related to
  work factor and salting are specified on a per-site basis.
\end{packed_desc}

Other authentication types will be added as Custos matures. It's also
possible for Custos implementations to support non-standard types, but
this may effect inter-implementation compatibility. Implementations
that do use their own types may wish to propose them as official types
so that other implementations will support them as well.

\subsection{Access Example}

As an example showing the full access control process, consider a
Custos-backed encrypted file system application. Figure
\ref{fig:arch-request} shows two users of this application attempting
to access an encrypted file. In order to decrypt the file and provide
access, the encrypted file system must query Custos for the necessary
encryption keys.

\begin{figure}[!tb]
  \vspace{5ex}
  \begin{center}
    \includegraphics[width=.75\textwidth]
                    {./figs/out/Arch-KeyRequest-All.pdf}
  \end{center}
  \caption{An Example Custos Request Sequence for an Encrypted File
    System}
  \label{fig:arch-request}
\end{figure}

The first user (red) is a daemon process running on a headless server
(IP = 1.2.3.4). The encryption key for the file the daemon wishes to
read has an ACS associated with it that grants the \texttt{obj\_read}
permission on the basis of the host IP and the time:

\begin{Verbatim}[samepage=true]
{
  obj_read:
    [
      [ (ip_src = '1.2.3.4'), (time_utc = '1300 +/- 5') ]
      ...
    ]
  ...
}
\end{Verbatim}

When the daemon reads the file, the encrypted file system requests the
associated encryption key from the server (dashed red line). The
request passes through the access control module, which looks up the
Access Control Chains associated with the \texttt{obj\_read}
permission for the requested key:value pair. The requests is then
passed to each of the necessary Authentication Attribute modules in
the order they appear in the ACC. Because the request is coming from
an allowed IP, it passes the source IP verification module. Next, as
long as the request is being made within 5 minutes of 1300 hours UTC,
the request will also pass the time verification module. After
satisfying both attributes specified in the ACC, the request is
granted the \texttt{obj\_read} permission and passed to the audit
module for logging. Finally, the server looks up the requested
key:value object (in this case the encryption key for the
corresponding file) in the key:value store, generates a response, and
returns it to the encrypted file system. The file system decrypts the
file and returns it to the daemon that originally made the read
request. All of this is done without any interactive input on the part
of the daemon, overcoming one of the traditional obstacles to using
encryption with automated processes.

The second user (blue) is a live user named Dirk also trying to read a
file on the encrypted file system. The encryption key for the file the
user wishes to read has an ACS associated with it that contains the
\texttt{obj\_read} permission and grants access to this permission on
the basis of the user ID and a password:

\begin{verbatim}
{
  obj_read:
    [
      [ (user_id = 'Dirk'), (psk = 'WorldOfBeer') ]
      ...
    ]
  ...
}
\end{verbatim}

When the user reads the file, the encrypted file system requests the
associated encryption key from the server (dashed blue line),
attaching the current user's ID of 'Dirk' to the request (but
excluding the password). The request passes through the access control
module, which, as before, looks up the Access Control Chains
associated with the obj\_read permission for the requested key:value
pair. The request is then passed to the user ID verification
authentication plugin, which confirms that the user ID of Dirk is
present, next the request is passed to the PSK module for password
verification. Unfortunately, the request lacks the necessary password,
so the server responds to the request informing the encrypted file
system that a password is required for user 'Dirk'. The encrypted file
system prompts the user for their password, and reissues the request,
including everything from the first request and in addition the newly
provided password (dotted blue line). This time the request clears
both AA verification modules, passes through the auditing system, and
finally hits the actual key:value store. Here the server looks up the
requested key, generates a response, and returns it to the file
system. The file system decrypts the requested file and allows the
user's read operation to proceed on the resulting clear text.

\section{API}

The Custos API is the primary interface for interacting with a Custos
server. The API handles, data, management, and auditing requests
through a common interface. All API requests pass authentication
attributes as a means of attaining the necessary permission level for
a requested operation. The order in which these authentication
attributes are passed in each request is not relevant. Custos treats
them as a heap of attributes and attempts to extract attributes from
the heap in an order that will satisfy the requirements of a specific
ACS. The API is RESTful and primarily stateless (individual
authentication modules are allowed to maintain state if required).

API requests are made to specific server HTTP endpoints. The standard
HTTP verbs (\texttt{GET}, \texttt{PUT}, \texttt{POST}, and
\texttt{DELETE}) are used to multiplex related operations atop a
specific endpoint. Each combination of endpoint and verb defines a
specific API method. Each method requires a specific permission to
complete. The API request and response message formats are composed in
JSON. Binary data is encoded as Base64 ASCII text. Authentication
attributes are passed via query string as URL encoded JSON. Custos
uses UUIDs~\cite{Leach2005} as keys, each associated with an arbitrary
object for values. In general, the server is responsible for object
UUID generation at object creation time.

\subsection{Message Format}

API requests and responses use standard JSON objects as the basis for
their message formats. The effect of the message is determined by its
content, as well as the endpoint and verb used to send it to the
server. Example API messages can be found in Appendix
\ref{appx:messages}. The basic JSON objects used to compose Custos
requests or responses include:

\noindent
\texttt{Attr} objects: JSON Dictionaries representing AAs. Includes
the following keys:

\begin{packed_desc}
\item[\texttt{Class}] \hfill \\ The AA class.
\item[\texttt{Type}] \hfill \\ The AA type.
\item[\texttt{Value}] \hfill \\ The AA value, encoded as Base64 ASCII.
\item[\texttt{Echo}] \hfill \\ A Boolean indicting whether or not the
  server should (when possible) echo the value of the \texttt{Attr}
  contained in a request back to the user in the response.
\item[\texttt{Status} (Response Only)] \hfill \\ The status indicating
  whether a given AA was accepted, denied, ignored, or required.
\item[\texttt{ResValue} (Response Only)] \hfill \\ An arbitrary
  response from a given AA module providing details on the nature of
  the status or instructions on how to continue. Encoded as Base64
  ASCII.
\end{packed_desc}

\noindent
\texttt{Key} objects: JSON dictionaries represent key:value
objects. Includes the following keys:

\begin{packed_desc}
\item[\texttt{Value}] \hfill \\ The object value, encoded as
  Base64 ASCII.
\item[\texttt{Echo}] \hfill \\ A Boolean indicting whether or not the
  server should (when possible) echo the value of the \texttt{Key}
  contained in a request back to the user in the response.
\item[\texttt{UUID} (Response Only)] \hfill \\ The UUID identifying
  the key.
\item[\texttt{Revision} (Response Only)] \hfill \\ The key revision.
\item[\texttt{Status} (Response Only)] \hfill \\ The status indicating
  whether the requested operation on the Key was allowed or denied.
\end{packed_desc}

\noindent
\texttt{ACS} objects: JSON dictionaries representing ACSs. Includes
the following keys:

\begin{packed_desc}
\item[\texttt{Permissions}] \hfill \\ A dictionary of permission:(ACC
  list) pairs. Each ACC list is, in turn a list of \texttt{Attr} JSON
  objects
\item[\texttt{Echo}] \hfill \\ A Boolean indicating whether or not the
  server should (when possible) echo the value of the \texttt{ACS}
  contained in a request back to the user in the response.
\item[\texttt{Status} (Response Only)] \hfill \\ The status indicating
  whether the requested operation on the ACS was allowed or denied.
\end{packed_desc}

All API requests contain an order-agnostic list of \texttt{Attrs} JSON
objects passed in a \texttt{aa=} query string parameter attached to
each request URL. Requests making use of one the of \texttt{override}
permission pass an additional \texttt{ovr=true} parameter to signal
the server that the associated AAs should be processed against the
appropriate override permission ACC instead of the standard permission
ACC. All query string parameters are URL encoded prior to being
attached. Requests that refer to specific groups pass the group UUID
as part of the URL. Likewise, requests referencing specific objects
pass the object UUID as part of the URL.

In addition to the above data, Custos requests that create or update
objects or ACSs pass the object/ACS value in the \texttt{POST} or
\texttt{PUT} message body as a JSON dictionary. On creation, this JSON
dictionary contains a \texttt{Key} JSON object stored under the
\texttt{``Key''} key, as well as an \texttt{ACS} JSON object stored
under the \texttt{``ACS''} key. An object update works the same way,
but only the \texttt{``Key''} key and associated JSON object are
passed. Likewise, an ACS update passes only the \texttt{``ACS''} key
and the associated JSON object. All Custos \texttt{POST} and
\texttt{PUT} requests may contain an optional \texttt{chk=} query
string parameter containing a list of checksums for the corresponding
request body data.

Custos responses are returned as JSON dictionary objects containing
one or more key:value pairs. All Custos responses contain the
following required dictionary keys:

\begin{packed_desc}
\item[\texttt{Status}] \hfill \\ The integer status code of the
  response. Used to indicate errors processing the corresponding
  request (malformed request, etc).
\item[\texttt{Attrs}] \hfill \\ A list of \texttt{Attr} JSON
  objects. Used to identify or prompt for the AAs associated with the
  corresponding request.
\end{packed_desc}

\noindent
Each response may also optionally contain any of the following
dictionary keys:

\begin{packed_desc}
\item[\texttt{Keys}] \hfill \\ A list of \texttt{Key} JSON
  objects. Used to provide the key:value objects associated with the
  corresponding request.
\item[\texttt{ACSs}] \hfill \\ A list of \texttt{ACS} JSON
  objects. Used to provide the ACSs associated with the corresponding
  request.
\end{packed_desc}

The API also makes use of standard HTTP codes to return statuses when
responding to requests. Successful requests return code
\texttt{200}. Malformed and otherwise corrupt requests return relevant
error codes.

\subsection{Endpoints}

Custos messages are sent to the Custos server via a series of
endpoints. Each endpoint relates to a specific data object or class
of data objects on the Custos server. These objects can be manipulated
in various ways using the standard HTTP verbs. I'll present each
endpoint categorized by the subsystem it is primarily associated with
(data, auditing, or management).

The data endpoints are used to create, access, update, and delete
Custos key:value objects or groups. The data endpoints, their
associated verbs, and the required permissions are shown in Table
\ref{tab:methods-data}.

\begin{table}[!tbh]
  \vspace{1ex}
  \begin{center}
    \tabulinesep = 5pt
    \begin{tabu} to \textwidth
      { | X[2.5,l,m]
        | X[.5,l,m]
        | X[1,l,m]
        | X[1,l,m]
        | }
      \hline
      \textbf{Endpoint}
      & \textbf{Verb}
      & \textbf{Required Permission}
      & \textbf{Purpose}
      \\ \hline
      \texttt{/grp}
      & \texttt{POST} & \texttt{srv\_grp\_create}
      & create a new group, returning the group's UUID
      \\ \hline
      \texttt{/grp}
      & \texttt{GET} & \texttt{srv\_grp\_list}
      & return the list of all groups
      \\ \hline
      \texttt{/grp/$\langle$grp\_uuid$\rangle$}
      & \texttt{DELETE} & \texttt{grp\_delete}
      & remove a group
      \\ \hline
      \texttt{/grp/$\langle$grp\_uuid$\rangle$/obj}
      & \texttt{POST} & \texttt{grp\_obj\_create}
      & create a new key:value object, returning the object's UUID
      \\ \hline
      \texttt{/grp/$\langle$grp\_uuid$\rangle$/obj}
      & \texttt{GET} & \texttt{grp\_obj\_list}
      & return a list of all key:value objects
      \\ \hline
      \texttt{/grp/$\langle$grp\_uuid$\rangle$/obj/$\langle$obj\_uuid$\rangle$}
      & \texttt{PUT} & \texttt{obj\_update}
      & update an existing key:value object
      \\ \hline
      \texttt{/grp/$\langle$grp\_uuid$\rangle$/obj/$\langle$obj\_uuid$\rangle$}
      & \texttt{GET} & \texttt{obj\_read}
      & return a key:value object$^{\ast}$
      \\ \hline
      \texttt{/grp/$\langle$grp\_uuid$\rangle$/obj/$\langle$obj\_uuid$\rangle$}
      & \texttt{DELETE} & \texttt{obj\_delete}
      & delete a key:value object
      \\ \hline
    \end{tabu}
  \end{center}
  \caption{Data API Methods}
  \label{tab:methods-data}
  ${}^\ast$ The \texttt{rev=} query string parameter may be used to
  specify a specific object version, otherwise the latest version is
  returned
\end{table}

The audit endpoints are used to audit data related to a specific
Custos OU. The audit endpoints, their associated verbs, and the
required permissions are shown in Table \ref{tab:methods-audit}.

\begin{table}[!tbh]
  \vspace{1ex}
  \begin{center}
    \tabulinesep = 5pt
    \begin{tabu} to \textwidth
      { | X[2.5,l,m]
        | X[.5,l,m]
        | X[1,l,m]
        | X[1,l,m]
        | }
      \hline
      \textbf{Endpoint}
      & \textbf{Verb}
      & \textbf{Required Permission}
      & \textbf{Purpose}
      \\ \hline
      \texttt{/audit}
      & \texttt{GET} & \texttt{srv\_audit}
      & return the server-wide audit data
      \\ \hline
      \texttt{/audit}
      & \texttt{DELETE} & \texttt{srv\_clean}
      & purge the server-wide audit data
      \\ \hline
      \texttt{/grp/$\langle$grp\_uuid$\rangle$/audit}
      & \texttt{GET} & \texttt{grp\_audit}
      & return the group-wide audit data
      \\ \hline
      \texttt{/grp/$\langle$grp\_uuid$\rangle$/audit}
      & \texttt{DELETE} & \texttt{grp\_clean}
      & purge the group-wide audit data
      \\ \hline
      \texttt{/grp/$\langle$grp\_uuid$\rangle$/obj/$\langle$obj\_uuid$\rangle$/audit}
      & \texttt{GET} & \texttt{obj\_audit}
      & return the audit data associated with a key:value object
      \\ \hline
      \texttt{/grp/$\langle$grp\_uuid$\rangle$/obj/$\langle$obj\_uuid$\rangle$/audit}
      & \texttt{DELETE} & \texttt{obj\_clean}
      & purge the audit data associated with a key:value objects
      \\ \hline
    \end{tabu}
  \end{center}
  \caption{Audit API Methods}
  \label{tab:methods-audit}
\end{table}

The management endpoints are used to manage access rights related to a
specific Custos OU. The audit endpoints, their associated verbs, and
the required permissions are shown in Table \ref{tab:methods-mgmt}.

\begin{table}[!tbh]
  \vspace{1ex}
  \begin{center}
    \tabulinesep = 5pt
    \begin{tabu} to \textwidth
      { | X[2.5,l,m]
        | X[.5,l,m]
        | X[1,l,m]
        | X[1,l,m]
        | }
      \hline
      \textbf{Endpoint}
      & \textbf{Verb}
      & \textbf{Required Permission}
      & \textbf{Purpose}
      \\ \hline
      \texttt{/acs}
      & \texttt{GET} & \texttt{srv\_acs\_get}
      & return the ACS associated with a server
      \\ \hline
      \texttt{/acs}
      & \texttt{POST} & \texttt{srv\_acs\_set}
      & set a new ACS associated with a server
      \\ \hline
      \texttt{/grp/$\langle$grp\_uuid$\rangle$/acs}
      & \texttt{GET} & \texttt{grp\_acs\_get}
      & return the ACS associated with a group
      \\ \hline
      \texttt{/grp/$\langle$grp\_uuid$\rangle$/acs}
      & \texttt{PUT} & \texttt{grp\_acs\_set}
      & set the ACS associated with a group
      \\ \hline
      \texttt{/grp/$\langle$grp\_uuid$\rangle$/obj/$\langle$obj\_uuid$\rangle$/acs}
      & \texttt{GET} & \texttt{obj\_acs\_get}
      & return the ACS associated with a key:value object
      \\ \hline
      \texttt{/grp/$\langle$grp\_uuid$\rangle$/obj/$\langle$obj\_uuid$\rangle$/acs}
      & \texttt{PUT} & \texttt{obj\_acs\_set}
      & set the ACS associated with a key:value object
      \\ \hline
    \end{tabu}
  \end{center}
  \caption{Management API Methods}
  \label{tab:methods-mgmt}
\end{table}

\section{Implementation}

I have completed example Custos implementations for both a Custos
server and a Custos client library. These implementations adhere to
the architectures and interfaces discussed thus far and represent the
``0.2-dev'' Custos specification and API revision. These
implementations are merely for proof-of-concept and reference
usage. They have not been optimized for performance, scalability,
etc. Building high-volume, fully production ready implementations is
left to future work (see Chapter \ref{chap:conclusion}).

\subsection{Server}

The reference server implementation is written in Python 2.7
leveraging the Flask microframework~\cite{python-flask}. This
framework simplifies the exposure of endpoints and handling of HTTP
requests. It interfaces with the local web server
(Apache~\cite{apache} in this case) via the WSGI~\cite{pep-wsgi}
interface. A Custos server could easily be implemented in any web-app
friendly language (i.e. Python, Go, Ruby, Java, etc). Python was
selected for its ease of use and rapid prototyping capabilities.

The reference server implementation does not use a discreet backing
key:vale store. Instead, it stores all data in local files via the
Python shelve~\cite{python-shelve} interface. Again, this was done for
rapid prototyping and easy troubleshooting. This interface could be
easily replaced with a production NoSQL-like key:value store
(i.e. MongoDB~\cite{mongodb}, Cassandra~\cite{cassandra}, etc).

When handling requests, the server primarily adheres to the
description provided in this chapter. There are, however, a few
limitations to the implementation. Currently, the implementation
ignores the group attributes, treating all requests as coming from a
single global group. Since groups are only necessary in a multi-tenant
scenario, this compromise seems acceptable for a prototype
implementation. Also, not all server-wide API calls are supported at
this time. The corresponding parameters are manually configured where
not yet supported via the API. Beyond that, the reference
implementation functions as described, and is capable of supporting
basic key:value storage and access control workloads.

The server implementation is actually surprisingly short: about a
thousand lines of python code in its basic form. The bulk of the code
is spent performing the necessary Access Control regulations. This
seems reasonable given that the bulk of the Custos server exists for
the purpose of performing access control. The use of a web-app
friendly language clearly reduces the amount of code required by
allowing most of the complexity associated with networking and message
exchange to be handed off to separate libraries. Using a preexisting
backing store also simplifies the Custos code base by avoiding the
need to build an entirely new key:value storage database from scratch.

\subsection{Client}

On the client front, I've create a reference client library
appropriate for use with C-based applications:
\texttt{libcustos}. I'll discuss the details of actual examples
applications in Chapter \ref{chap:clients}, but the client library
itself is discussed here. A C library is necessary due to the lack of
native support for many of the components of the Custos architecture
in the C programming language (e.g. JSON, HTTP communication,
dictionaries, etc). Higher level languages like (i.e. Python) have a
much easier time interfacing with the Custos architecture and thus may
not require full blown interface libraries.

\texttt{libcustos} leverages the Curl~\cite{curl} library for
performing HTTP requests. It uses the \texttt{json-c}~\cite{json-c}
library for building and decoding JSON data structures. It also
leverage various third party libraries for Base64 encoding, UUID
generation, and checksum generation.

\texttt{libcustos} deals with translating Custos JSON messages into C
data structures. It exposes a series of functions for dealing with
Custos data types, handling data type memory management, making Custos
requests, and processing the resulting response. The library aims to
be thread-safe and defensively coded. It makes it easy to interface C
applications with the Custos architecture. It could also be used by
languages that accept C-bindings like C++ or Python.

Compared to the server, the \texttt{libcustos} implementation is quite
a bit longer: about 5000 lines of C code. This is largely due to the
extra effort required to properly and safely convert between Custos
message formats and C data structures. The code would be even longer
if not for the use of separate libraries for handling the core
communication primitives. This length, however, does show the
importance of having a C-based client library: many file systems and
encryption systems are written in C, and it would be impractical for
these applications to fully implement the Custos protocol directly due
to the complexity involved. Applications based on higher level
languages would likely have better luck directly interfacing with
Custos.

%%  LocalWords:  ACS ACCs ACC OU srv grp src ip usernames auth acs aa
%%  LocalWords:  username AAs tls psk sha bcrypt utc del ReqID ResID
%%  LocalWords:  Attrs ACSs Attr ResValue req contentType json dev
%%  LocalWords:  MongoDB libcustos objs grps OU's uuid OUs chk Custos
%%  LocalWords:  Custos's
